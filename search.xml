<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数字图像处理之错切问题]]></title>
    <url>%2F2020%2F11%2F01%2F%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A.html</url>
    <content type="text"><![CDATA[问题描述 修正原理 MATLAB代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function []=Stamp(Origin_path, Need_to_fix_picture_path)%% 本函数用于修正印章的错切问题% Input:% Origin_path:原始理想图的存放路径% Need_to_fix_picture_path：待修复的图存放路径 % 手动映射采点 bad=[285,165; 170,62; 265,104; 294,133; 81,71; 240,63; 220,119; 79,104; 148,62]; good=[205,167,1;139,62,1;216,105,1;231,133,1;46,70,1;211,63,1;163,119,1;28,105,1;119,61,1]; % 回归得到错切修正系数 Parameter_X=regress(bad(:,1),good); Parameter_Y=regress(bad(:,2),good); % 载入错切后图片与原图片,并显示 picture=imread(Need_to_fix_picture_path); % 错切图存放地址 Shape=size(picture); target=imread(Origin_path); % 原始图存放地址 target_size=size(target); figure(1); subplot(1,3,1); imshow(picture); title('Need to fix'); subplot(1,3,2); imshow(target); title('target'); % 根据原图和错切图建立映射，修复错切问题 Store_Matrix=ones(target_size(1),target_size(2),3)*255; for channel=1:3 for x=1:target_size(1) for y=1:target_size(2) if floor([x,y,1]*Parameter_X)&gt;=Shape(1) continue; end if floor([x,y,1]*Parameter_Y)&gt;=Shape(2) continue; end Store_Matrix(x,y,channel)=picture(floor([x,y,1]*Parameter_X),floor([x,y,1]*Parameter_Y),channel); end end end % 显示修复后结果 Store_Matrix=uint8(Store_Matrix); subplot(1,3,3); imshow(Store_Matrix); title('fixed picture');end 修正结果]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VHDL语言入门]]></title>
    <url>%2F2020%2F07%2F11%2FVHDL%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8.html</url>
    <content type="text"><![CDATA[语言描述法1. 结构描述法这种方法的前提是知道逻辑函数的表达式。下面以2位比较器为例子来进一步说明。1AeqB&lt;=NOT((a(0) XOR b(0)) OR (a(1) XOR b(1)) OR(a(2) XOR b(2)) OR (a(3) XOR b(3))); 2. 行为描述法这种方法从功能上进行编程，效率非常高。1AeqB&lt;='1' WHEN a=b ELSE '0' 数据类型 BIT:位类型，其值只能为‘0’或‘1’。 Std_Logic标准逻辑类型。 (1).可以代替BIT和BIT_VECTOR(多位)。 (2).电路中存在三态逻辑必须用STD_LOGIC和STD_LOGIC_VECTOR。 (3)在使用Std_Logic数据类型时必须声明库和程序包说明语句：12LIBRARY ieee;USE ieee.std_logic_1164.ALL; 算术运算符 运算符 功能 运算符 功能 + 加 SLL 逻辑左移 - 减 SRL 逻辑右移 * 乘 SLA 算术左移 / 除 SRA 算术右移 ** 乘方 ROL 逻辑循环左移 MOD 取模 ROR 逻辑循环右移 REM 取余 ABS 取绝对值 逻辑运算符 运算符 功能 AND 与 OR 或 NAND 与非 NOR 或非 XOR 亦或 XNOR 亦或非 NOT 非 其他运算符 运算符 功能 + 正 - 负 &amp; 并置 VHDL程序基本结构123456789101112LIBRARY ieee;USE ieee.std_logic_1164.ALL; --库说明ENTITY mux21 IS --实体说明 PORT(A, B, SEL:IN STD_LOGIC; Y:OUT STD_LOGIC);END mux21;ARCHITECTURE one OF mux21 IS --结构体说明 BEGINY&lt;=(A AND NOT SEL) OR (B AND SEL);END; 并行语句 布尔表达式 1Y&lt;=(A AND (NOT S)) OR (B AND S); 条件信号赋值语句 1234X&lt;= a when(s=="00") else b when(s=="01") else c when(s=="10") else d; 选择信号赋值语句 12345WITH s SELECTX&lt;= a WHEN"00", b WHEN"01", c WHEN"10", d WHEN OTHERS; 进程语句 12345678910--D触发器上升沿触发ARCHITECTURE one OF dff IS BEGIN PROCESS(clk) BEGIN IF clk'event AND clk='1' THEN q&lt;=d; END IF; END PROCESS;END; 1234567--D锁存器PROCESS(oe,a)BEGIN IF oe='1' THEN y&lt;=a; END IF;END PROCESS; 顺序语句 每一条顺序语句的执行顺序是和它们的书写顺序是一致的。它只能出现在进程，函数和过程中。 （1）顺序赋值语句 变量赋值目标：=赋值源 信号赋值目标：&lt;=赋值源 （2）IF语句12345678910111213IF 条件句 THEN 顺序语句ELSE 顺序语句END IF----------------------------IF 条件句 THEN 顺序语句 ELSIF 条件句 THEN 顺序语句 ELSE 顺序语句END IF (3)CASE_WHEN语句123456CASE 表达式 IS WHEN 选择值=&gt;顺序语句； ……… WHEN 选择值=&gt;顺序语句； [WHEN OTHERS=&gt;顺序语句；]END CASE; 下面以四选一数据选择器为例：123456789mux4_1:PROCESS(a,b,c,d,s) BEGIN CASE s IS WHEN"00"=&gt; x&lt;=a; WHEN"01"=&gt; x&lt;=b; WHEN"10"=&gt; x&lt;=c; WHEN OTHERS=&gt; x&lt;=d; END CASE; END PROCESS mux4_1; 变量123456789---变量声明VARIABLE tmp: Bit;---整体赋值temp:="1010101010";temp:=x"AA";---逐位赋值temp(7):='1';---多位赋值temp(7 downto 4) :="1010"; 信号123456789101112131415IBRARY ieee;USE ieee.std_logic_1164.ALL; ENTITY zuhe IS PORT(a,b,c,d:IN STD_LOGIC; g:OUT STD_LOGIC);END zuhe;ARCHITECTURE one OF zuhe IS SIGNAL e,f:Std_Logic; --信号全局声明 BEGIN e&lt;=a OR b; f&lt;=NOT(c OR d); g&lt;=e AND f;END;]]></content>
      <categories>
        <category>VHDL</category>
      </categories>
      <tags>
        <tag>VHDL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode优雅配置LaTeX]]></title>
    <url>%2F2020%2F07%2F11%2FVSCode%E4%BC%98%E9%9B%85%E9%85%8D%E7%BD%AELaTeX.html</url>
    <content type="text"><![CDATA[软件安装 TeXlive安装 VSCode安装 配置过程 在VSCode插件商店中下载LaTex Workshop插件。 使用ctrl+shift+p快捷键搜索Preferences: Open Settings(JSON)。打开的json文件即是VSCode的配置文件，可能在之前配置过python等其他语言，这次LaTeX配置只需要在末尾追加并保存： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960"latex-workshop.latex.recipes": [ &#123; "name": "xelatex", "tools": [ "xelatex" ] &#125;, &#123; "name": "xe*2", "tools": [ "xelatex", "xelatex" ] &#125;, &#123; "name": "xelatex -&gt; bibtex -&gt; xelatex*2", "tools": [ "xelatex", "bibtex", "xelatex", "xelatex" ] &#125; ], "latex-workshop.latex.tools": [&#123; "name": "latexmk", "command": "latexmk", "args": [ "-synctex=1", "-interaction=nonstopmode", "-file-line-error", "-pdf", "%DOC%" ] &#125;, &#123; "name": "xelatex", "command": "xelatex", "args": [ "-synctex=1", "-interaction=nonstopmode", "-file-line-error", "%DOC%" ] &#125;, &#123; "name": "pdflatex", "command": "pdflatex", "args": [ "-synctex=1", "-interaction=nonstopmode", "-file-line-error", "%DOC%" ] &#125;, &#123; "name": "bibtex", "command": "bibtex", "args": [ "%DOCFILE%" ] &#125;], "latex-workshop.view.pdf.viewer": "tab" 创建一个如下内容的.tex文件测试： 123456789101112131415161718\documentclass[letterpaper,11pt]&#123;article&#125; \usepackage&#123;latexsym&#125;\usepackage[empty]&#123;fullpage&#125;\usepackage&#123;titlesec&#125;\usepackage&#123;marvosym&#125;\usepackage[usenames,dvipsnames]&#123;color&#125;\usepackage&#123;verbatim&#125;\usepackage&#123;enumitem&#125;\usepackage[hidelinks]&#123;hyperref&#125;\usepackage&#123;fancyhdr&#125;\usepackage[english]&#123;babel&#125;\usepackage&#123;tabularx&#125;\usepackage[UTF8]&#123;ctex&#125; \begin&#123;document&#125;\textbf&#123;hello world 2020!&#125;\end&#123;document&#125; 按如下过程，编译运行。 结果展示： 参考文献1.https://blog.csdn.net/GodWriter/article/details/998297342.https://blog.csdn.net/yyhaohaoxuexi/article/details/86520926]]></content>
      <categories>
        <category>LaTeX</category>
        <category>VSCode</category>
      </categories>
      <tags>
        <tag>LaTex</tag>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scrapy爬虫实战--当当网]]></title>
    <url>%2F2020%2F07%2F10%2FScrapy%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98-%E5%BD%93%E5%BD%93%E7%BD%91.html</url>
    <content type="text"><![CDATA[看完Scrapy的概述，我们大概对Scrapy这个爬虫框架有了一个大致的了解。下面就通过爬取当当网python书籍信息来对Scrapy这个框架做一个实战。 创建一个项目文件夹，并打开终端cd到创建文件夹处。在该目录下，在终端输入：1scrapy startproject (爬虫项目名) &emsp; 通过执行这条命令，便会在当前文件夹下创建Scrapy的大致模板了。 进入工程文件夹，在终端输入：1scrapy genspider (爬虫py的名字) （爬取的范围） 在items.py中添加item项。12345678910111213141516171819202122# -*- coding: utf-8 -*-# Define here the models for your scraped items## See documentation in:# https://docs.scrapy.org/en/latest/topics/items.html#导入第三方库scrapyimport scrapy#定义有关需要爬取的数据的类DdpythonItem（当当pythonItem）class DdpythonItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() name=scrapy.Field() #书名 author=scrapy.Field() #作者 introduction=scrapy.Field() #简介 price=scrapy.Field() #价格 press=scrapy.Field() #出版社 time=scrapy.Field() #出版时间 comment_num=scrapy.Field() #评价数目 进入前面生成的爬虫py文件中，进行爬取方法的定义。1234567891011121314151617181920212223242526272829303132333435363738394041# -*- coding: utf-8 -*-# 导入第三方库scrapy以及自定义库items中的Item类DdpythonItemimport scrapyfrom ..items import DdpythonItem# 定义爬虫类DdSpider（当当Spider），爬虫名字命名为ddclass DdSpider(scrapy.Spider): name = 'dd' # 爬取的网站为当当网，开始的url为'http://search.dangdang.com/?key=python'（python类图书界面） allowed_domains = ['dangdang.com'] start_urls = ['http://search.dangdang.com/?key=python'] # 定义解析response对象的方法 def parse(self, response): # 使用 XPath 从页面的HTML源码中选择需要提取的数据 # 根据对HTML源码的观察，设置XPath解析规则提取出所有书籍信息books books = response.xpath('//ul[@class="bigimg"]/li') # 对提取到的所有图书信息进行遍历，提取每一本书的相关信息 for book in books: item = DdpythonItem() # 生成一个Item对象，用于存储提取到的信息 item['name'] = book.xpath('./a[@class="pic"]/@title').extract() item['introduction'] = book.xpath('./p[@class="detail"]/text()').extract() if len(book.xpath('./p[@class="detail"]/text()')) &gt; 0 else '无介绍信息' item['author'] = book.xpath('./p/span[1]/a[1]/@title').extract() if len(book.xpath('./p/span[1]/a[1]/@title')) &gt; 0 else '无作者信息' item['price'] = book.xpath('./p/span[@class="search_now_price"]/text()').extract() item['press'] = book.xpath('./p/span[3]/a/text()').extract() if len(book.xpath('./p/span[3]/a/text()')) &gt; 0 else '无出版社信息' item['time'] = book.xpath('./p[5]/span[2]/text()').extract() if len(book.xpath('./p[5]/span[2]/text()')) &gt; 0 else '无出版时间信息' item['comment_num'] = book.xpath('./p[@class="search_star_line"]/a/text()').extract() # 将提取到的数据提交给pipelines进行保存输出 yield item # 设置爬取的页面数pageNum，爬取10个页面的python图书信息 pageNum = 10 # 根据url的规则进行构建新的url，即page，将page提交给scrapy engine进行处理 for page in range(2, pageNum): page = 'http://search.dangdang.com/?key=python&amp;page_index=&#123;&#125;'.format(page) # 对页面page提交request请求，利用自定义的解析方法parse对获取到的页面进行解析 yield scrapy.Request(page, callback=self.parse) 在pipelines.py文件中，将item中提取的数据保存下来。1234567891011121314151617181920212223242526272829303132333435363738# -*- coding: utf-8 -*-# Define your item pipelines here## Don't forget to add your pipeline to the ITEM_PIPELINES setting# See: https://docs.scrapy.org/en/latest/topics/item-pipeline.html# 导入第三方库pymysql，用于对MySQL数据库进行处理import pymysql# 定义用于输出数据到MySQL数据库的Pipeline类DdpythonPipelineclass DdpythonPipeline(object): # 定义处理item对象的方法process_item def process_item(self, item, spider): # 通过pymysql对本地数据库进行连接，并且指定连接的数据库为“dd” db = pymysql.connect(host="Localhost",user="root",password="cpt200406",db="dd",charset="utf8") cursor = db.cursor() # 获取db的游标对象，用于对事务进行处理 # 根据提取的数据进行再次处理加工，转换成最终存储到数据库中的类型 name = item["name"][0] introduction=item["introduction"][0] author=item["author"][0] price = item["price"][0].strip('¥') # 删除价格前面的货币符￥ press = item["press"][0] time = item["time"][0].strip().strip('/') # 删除时间前面的‘/’ comment_num=item["comment_num"][0].strip('条评论')# 删除原始数据中的汉字‘条评论’ # 对数据库进行插入操作，将提取到的item对象中的数据插入到dd数据库的ddpython数据表中 cursor.execute('INSERT INTO ddpython(book_name,introduction,author,price,press,publication_time,comment_num) VALUES (%s,%s,%s,%s,%s,%s,%s)',(name,introduction,author,price,press,time,comment_num)) # 对事务操作进行提交 db.commit() # 关闭游标对象cursor以及数据库对象db cursor.close() db.close() # 返回item对象 return item 在settings.py中,将pipelines的配置打开123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990# -*- coding: utf-8 -*-# Scrapy settings for DDPython project## For simplicity, this file contains only settings considered important or# commonly used. You can find more settings consulting the documentation:## https://docs.scrapy.org/en/latest/topics/settings.html# https://docs.scrapy.org/en/latest/topics/downloader-middleware.html# https://docs.scrapy.org/en/latest/topics/spider-middleware.htmlBOT_NAME = 'DDPython'SPIDER_MODULES = ['DDPython.spiders']NEWSPIDER_MODULE = 'DDPython.spiders'# Crawl responsibly by identifying yourself (and your website) on the user-agent#USER_AGENT = 'DDPython (+http://www.yourdomain.com)'# Obey robots.txt rulesROBOTSTXT_OBEY = True# Configure maximum concurrent requests performed by Scrapy (default: 16)#CONCURRENT_REQUESTS = 32# Configure a delay for requests for the same website (default: 0)# See https://docs.scrapy.org/en/latest/topics/settings.html#download-delay# See also autothrottle settings and docs#DOWNLOAD_DELAY = 3# The download delay setting will honor only one of:#CONCURRENT_REQUESTS_PER_DOMAIN = 16#CONCURRENT_REQUESTS_PER_IP = 16# Disable cookies (enabled by default)#COOKIES_ENABLED = False# Disable Telnet Console (enabled by default)#TELNETCONSOLE_ENABLED = False# Override the default request headers:#DEFAULT_REQUEST_HEADERS = &#123;# 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',# 'Accept-Language': 'en',#&#125;# Enable or disable spider middlewares# See https://docs.scrapy.org/en/latest/topics/spider-middleware.html#SPIDER_MIDDLEWARES = &#123;# 'DDPython.middlewares.DdpythonSpiderMiddleware': 543,#&#125;# Enable or disable downloader middlewares# See https://docs.scrapy.org/en/latest/topics/downloader-middleware.html#DOWNLOADER_MIDDLEWARES = &#123;# 'DDPython.middlewares.DdpythonDownloaderMiddleware': 543,#&#125;# Enable or disable extensions# See https://docs.scrapy.org/en/latest/topics/extensions.html#EXTENSIONS = &#123;# 'scrapy.extensions.telnet.TelnetConsole': None,#&#125;# Configure item pipelines# See https://docs.scrapy.org/en/latest/topics/item-pipeline.htmlITEM_PIPELINES = &#123; 'DDPython.pipelines.DdpythonPipeline': 300,&#125;# Enable and configure the AutoThrottle extension (disabled by default)# See https://docs.scrapy.org/en/latest/topics/autothrottle.html#AUTOTHROTTLE_ENABLED = True# The initial download delay#AUTOTHROTTLE_START_DELAY = 5# The maximum download delay to be set in case of high latencies#AUTOTHROTTLE_MAX_DELAY = 60# The average number of requests Scrapy should be sending in parallel to# each remote server#AUTOTHROTTLE_TARGET_CONCURRENCY = 1.0# Enable showing throttling stats for every response received:#AUTOTHROTTLE_DEBUG = False# Enable and configure HTTP caching (disabled by default)# See https://docs.scrapy.org/en/latest/topics/downloader-middleware.html#httpcache-middleware-settings#HTTPCACHE_ENABLED = True#HTTPCACHE_EXPIRATION_SECS = 0#HTTPCACHE_DIR = 'httpcache'#HTTPCACHE_IGNORE_HTTP_CODES = []#HTTPCACHE_STORAGE = 'scrapy.extensions.httpcache.FilesystemCacheStorage' 进入工作目录文件夹，输入以下命令启动爬虫：1scrapy crawl (爬虫名)]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
        <category>实战</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scrapy爬虫简介]]></title>
    <url>%2F2020%2F07%2F08%2FScrapy%E7%88%AC%E8%99%AB%E7%AE%80%E4%BB%8B.html</url>
    <content type="text"><![CDATA[流程图 1.Spiders(爬虫):它负责处理所有Responses,从中分析提取数据，获取Item字段需要的数据，并将需要跟进的URL提交给引擎，再次进入Scheduler(调度器) 2.Engine(引擎)：负责Spider、ItemPipeline、Downloader、Scheduler中间的通讯，信号、数据传递等。 3.Scheduler(调度器)：它负责接受引擎发送过来的Request请求，并按照一定的方式进行整理排列，入队，当引擎需要时，交还给引擎。 4.Downloader(下载器)：负责下载Scrapy Engine(引擎)发送的所有Requests请求，并将其获取到的Responses交还给Scrapy Engine(引擎)，由引擎交给Spider来处理 5.ItemPipeline(管道):它负责处理Spider中获取到的Item，并进行进行后期处理（详细分析、过滤、存储等）的地方. 6.Downloader Middlewares（下载中间件）：你可以当作是一个可以自定义扩展下载功能的组件。 7.Spider Middlewares（Spider中间件）：你可以理解为是一个可以自定扩展和操作引擎和Spider中间通信的功能组件（比如进入Spider的Responses;和从Spider出去的Requests） 入门使用创建过程： 结构： spider使用： pipeline更改和使用： log简单设置： 翻页爬取方法： item的设置： 参考文献https://www.bilibili.com/video/BV1mf4y127S5#reply3147097466]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTeX环境搭建]]></title>
    <url>%2F2020%2F07%2F02%2FLaTeX%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</url>
    <content type="text"><![CDATA[软件安装工欲善其事，必先利其器。所以第一步当然是安装软件啦！主要安装的东西分为2部分：一部分是LaTex的编译器，另一部分则是LaTex的IDE环境，下面就开始我们的入门之旅吧！ 1).TeXlive安装 TeXlive镜像文件下载地址 下载完成后，使用虚拟光驱运行如下文件 然后根据自己的需求安装需要的包： 为了验证是否安装成功，可以进入Windows的命令行敲入如下命令。 2).IDE的安装① TeXstudio下载地址 ② TeXworks editor下载地址]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java期末练习]]></title>
    <url>%2F2020%2F06%2F14%2FJava%E6%9C%9F%E6%9C%AB%E7%BB%83%E4%B9%A0.html</url>
    <content type="text"><![CDATA[这期可能是关于Java的最后一期更新了！期末考试即将来临，老师终于官方的发题目啦！这让我倍感涕零。下面二话不说就抛代码了~ 题一（基本循环、选择语句） 编写Demo.java，输出10～100以内既能被2整除，又能被3整除的整数，要求每行只能打印5个数。 1234567891011121314151617181920212223public class Demo &#123; public static void main(String[] agrs) &#123; int count=0; String s=""; for(int i=10;i&lt;=100;i++) &#123; if(i%2==0 &amp;&amp; i%3==0) &#123; if(count&lt;5) &#123; count++; s+=Integer.toString(i); s+=" "; &#125; else &#123; count=1; System.out.println(s); s=""; s+=Integer.toString(i); s+=" "; &#125; &#125; &#125; System.out.println(s); &#125;&#125; 题二（类变量与类方法操作） 编写一汽车类Car，其具有以下属性： 品牌：brand，类型String；发动机排量:engineDisplacement, 类型：double； 速度：speed，类型double；状态：status，类型boolean； 最高时速：maxSpeed，类型double Car的方法： 构造方法：Car(String brand, double engineDisplacement, double maxSpeed) 启动：start( )，该方法使得status值变为true； 加速：speedUp( )，当汽车处于启动状态时，每调用一次，速度增加5，但速度不高于最高时速； 减速：slowDown( )，当汽车处于启动状态时，每调用一次，速度减5，但速度不小于0； 熄火：stop( )，当speed为0时，将status值变为false。 每个方法除改变成员变量外，还要打印出方法执行后的状态和速度。 试完成Car类的实现，并且编写main方法，实例化一个Car对象，其中品牌为”宝马”，排量2.0，最高时速为160，依次执行启动该汽车，加速到120，再减速到0，最后熄火，要求显示各执行结果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Car &#123; private String brand; private double engineDisplacement; private double speed=0; private boolean status=false; private double maxSpeed; public Car(String brand, double engineDisplacement,double maxSpeed) &#123; this.brand=brand; this.engineDisplacement=engineDisplacement; this.maxSpeed=maxSpeed; System.out.println("Car构造函数执行后的status:"+this.status+",speed:"+this.speed); &#125; public void start() &#123; this.status=true; System.out.println("start函数执行后的status:"+this.status+",speed:"+this.speed); &#125; public void speedUp() &#123; if(this.status==true &amp;&amp; this.speed+5&lt;=this.maxSpeed) this.speed+=5; System.out.println("speedUp函数执行后的status:"+this.status+",speed:"+this.speed); &#125; public void slowDown() &#123; if(this.status==true &amp;&amp; this.speed-5&gt;=0) this.speed-=5; System.out.println("slowDown函数执行后的status:"+this.status+",speed:"+this.speed); &#125; public void stop() &#123; if(this.speed==0) this.status=false; System.out.println("stop函数执行后的status:"+this.status+",speed:"+this.speed); &#125; public static void main(String[] args) &#123; Car c=new Car("宝马",2.0,160); c.start(); for(int i=0;i&lt;24;i++) &#123; c.speedUp(); &#125; for(int i=0;i&lt;24;i++) &#123; c.slowDown(); &#125; c.stop(); &#125;&#125; 题三（异常处理）编写一银行类Bank，其中存款余额：balance，要求： (1)构造函数：Bank(int balance)； (2)存款操作：deposit( )； (3)取款操作：withdraw( )； (4)获取余额：getBalance( )； 编写main函数，实例化Bank对象，初始给定存款100，存入50，打印余额，连续取款120，40，打印余额。要求用自定义异常处理方式解决余额不足的问题。 123456789101112131415161718192021222324252627282930313233343536373839404142public class Bank &#123; private double balance; public Bank(int balance) &#123; this.balance=balance; &#125; public void deposit(double store) &#123; this.balance+=store; &#125; public void withdraw(double draw) &#123; try &#123; if(this.balance-draw&lt;0) throw new Exception("余额不足！无法取出"); else this.balance-=draw; &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; public double getBalance() &#123; return this.balance; &#125; public static void main(String[] args) &#123; Bank bk=new Bank(100); System.out.println("原账户余额："); System.out.println(bk.getBalance()); bk.deposit(50); System.out.println("存入50元操作后余额："); System.out.println(bk.getBalance()); bk.withdraw(120); System.out.println("去除120元操作后余额："); System.out.println(bk.getBalance()); bk.withdraw(40); System.out.println("去除40元操作后余额："); System.out.println(bk.getBalance()); &#125;&#125; 题四（GUI设计） 利用Swing组件编写一个界面大小400×300像素的简易文本编辑器MyTextEditor，要求： (1)程序启动后，多行文本输入框JTextArea中显示当前目录下myText.txt文件中原有内容，如果该文件不存在，则新建文件； (2)保存(按钮)功能：将编辑器界面输入的内容写入myText.txt文件中保存； (3)取消(按钮)功能：将文本框中内容清空； (4)退出(按钮)功能：退出程序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import javax.swing.*;import java.awt.*;import java.io.*;import java.util.*;import java.awt.event.*;public class MyTextEditor extends JFrame implements ActionListener&#123; //成员变量 JButton b1,b2,b3; JTextArea area; String text; //构造函数 MyTextEditor(String xTitle)&#123; super(xTitle); //设置标题 setSize(400,300); //设置窗口大小 Container c=getContentPane(); //获得容器 c.setLayout(new GridLayout(2,1)); //设置布局 JPanel panel1=new JPanel(); //设置输入框小容器 panel1.setLayout(new FlowLayout(FlowLayout.CENTER)); area=new JTextArea(); area.setBackground(Color.green); area.setLineWrap(true); panel1.add(area); c.add(panel1); JPanel panel2=new JPanel(); //设置保存，取消，退出按钮 panel2.setLayout(new FlowLayout(FlowLayout.CENTER)); b1=new JButton("保存"); b1.addActionListener(this); //设置事件监督 b2=new JButton("取消"); b2.addActionListener(this); b3=new JButton("退出"); b3.addActionListener(this); panel2.add(b1); panel2.add(b2); panel2.add(b3); c.add(panel2); //小容器放入大容器中 setVisible(true); //显示许可 File f=new File("myText.txt"); //创建File变量 if(f.exists()==false) &#123; //是否存在该目录，不存在创建 try&#123; f.createNewFile(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; //读入txt中的文字 try &#123; FileReader fr=new FileReader("myText.txt"); BufferedReader br=new BufferedReader(fr); String aline; while(br.ready()) &#123; aline=br.readLine(); area.append(aline+"\r\n"); &#125; fr.close(); br.close(); &#125;catch(IOException e) &#123; e.printStackTrace(); &#125; &#125; //编写事件的接口方法 public void actionPerformed(ActionEvent e) &#123; if(e.getSource()==b1) &#123; //若按下保存按钮 String store; store=area.getText(); //获得目前文本框中内容 try &#123; //实现写入txt功能 FileWriter fw=new FileWriter("myText.txt"); fw.write(store); fw.close(); &#125; catch(IOException t)&#123; t.printStackTrace(); &#125; &#125; else if(e.getSource()==b2) &#123; //按下取消按钮 area.setText(""); //清空文本框中内容 area.setEditable(true); &#125; else &#123; System.exit(0); //按下退出按钮，退出 &#125; &#125; //测试main函数 public static void main(String[] agrs) &#123; MyTextEditor m=new MyTextEditor("MyTextEditor"); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Java的GUI设计]]></title>
    <url>%2F2020%2F06%2F13%2FJava%E7%9A%84GUI%E8%AE%BE%E8%AE%A1.html</url>
    <content type="text"><![CDATA[在2020的今天，GUI，可能已经是大家耳熟能详的词了。所谓GUI即是用户界面，像我们的QQ，WeChat等等都是以用户界面的形式呈现在我们眼前的。而Java作为一种运用广泛的程序语言，自然在GUI设计上也有其独特之处。下面就以2道常规GUI题来实战一下吧！此次的题目以及代码是我们优秀的冯py同学投稿！大家慢慢欣赏哦！ 题1创建一个可以移动、改变大小、最大化、且可以关闭的JFrame窗口，并且添加菜单和工具条；设计相应的菜单加速键以及快捷键图标。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124import java.awt.*;import javax.swing.*;import java.awt.event.*;public class test extends JFrame&#123; //定义菜单 JMenuBar mb = new JMenuBar(); //工具栏对象 JToolBar mtb = new JToolBar(); JMenu mFile = new JMenu("文件(F)"); JMenuItem miNew=new JMenuItem("新建(N)",KeyEvent.VK_N), miOpen=new JMenuItem("打开(O)...",KeyEvent.VK_O), miSave=new JMenuItem("保存(S)",KeyEvent.VK_S), miFont=new JMenuItem("字体与颜色(F)...",KeyEvent.VK_F), miQuit=new JMenuItem("退出(X)",KeyEvent.VK_X); //菜单选项 //构造函数 test(String sTitle)&#123; super(sTitle); //添加组件 addMenus(); //设置窗口大小 setSize(500,300); //设置close按钮操作 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); //设置工具栏 addToolBar(); //设置输入框 addTextField(); //添加按钮 addButton(); &#125; //添加菜单 private void addMenus() &#123; setJMenuBar(mb); //设置快捷键 miNew.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_N,InputEvent.CTRL_DOWN_MASK)); miOpen.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O,InputEvent.CTRL_DOWN_MASK|InputEvent.SHIFT_DOWN_MASK)); mFile.add(miNew); //新建 mFile.add(miOpen); //打开 mFile.add(miSave); //保存 mFile.addSeparator(); //分割线 mFile.add(miFont); //字体和颜色 mFile.addSeparator(); //分割线 mFile.add(miQuit); //退出 mb.add(mFile); /*//改变窗口坐标 Toolkit tk = getToolkit();//得到一个Toolkit对象 Image icon = tk.getImage("online.gif"); setIconImage(icon);*/ &#125; //添加工具条 private void addToolBar() &#123; //工具条 Container c = getContentPane(); c.add(BorderLayout.NORTH,mtb); mtb.setLayout(new FlowLayout(FlowLayout.LEFT)); FgButton [] btn = &#123;new FgButton("新建文件"), new FgButton("打开文件"), new FgButton("保存文件")&#125;; for (int i = 0; i &lt; btn.length; i++) &#123; btn[1].setBorder(BorderFactory.createEmptyBorder()); mtb.add(btn[i]); &#125; //设置不可以浮动 mtb.setFloatable(false); &#125; //添加标签和输入框 public void addTextField() &#123; Container c = getContentPane(); c.setLayout(new FlowLayout()); c.add(new JLabel("用户名：")); c.add(new JTextField("",15)); c.add(new JLabel("密 码 ：")); c.add(new JPasswordField("",15)); &#125; //按钮添加 public void addButton() &#123; Container c=getContentPane(); JButton[] ic = &#123;new JButton("登入")&#125;; c.add(ic[0]); &#125; //测试函数 public static void main(String[] args) &#123; //创建窗口对象 test frm = new test("one"); //显示窗口 frm.setVisible(true); &#125; &#125;//自定义按钮class FgButton extends JButton&#123; public FgButton()&#123; super(); &#125; //Icon对象用来引入图片 public FgButton(Icon icon,String strToolTipText)&#123; super(icon); setToolTipText(strToolTipText); &#125; public FgButton(String strToolTipText)&#123; setToolTipText(strToolTipText); &#125;&#125; 题2设计编写登录窗口，该应用程序维护一张记录合法用户名和密码的列表；只有合法的用户才能通过登录程序；需要实现：1）最多尝试3次；2）登录成功推出登录窗口；3）用户名或密码为空时，提示信息；4）用户名和密码错误时，清空密码，并将用户名选中；5）居中显示窗口。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import javax.swing.*;import java.awt.event.*;import java.util.*;import java.awt.*;public class TestTextField extends JFrame implements ActionListener&#123; JTextField t0,t1; JButton jb; int count=3; Map&lt;String, Integer&gt; map=new HashMap&lt;String,Integer&gt;(); //构造函数 public TestTextField(String xTitle)&#123; super(xTitle); //为窗口设置名字 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setSize(250,200); //设置窗口大小 Container c=getContentPane(); //获得窗口容器 c.setLayout(new GridLayout(3,1)); // 为容器设置布局 //用户名panel JPanel panel1=new JPanel(); //创建小容器 panel1.setLayout(new FlowLayout(FlowLayout.CENTER));//设置小容器的布局 panel1.add(new JLabel("用户名:")); //添加标签 t0=new JTextField("",15); panel1.add(t0); //添加输入框 c.add(panel1); //把小容器放到大容器中 //密码panel JPanel panel2=new JPanel(); //创建小容器 panel2.setLayout(new FlowLayout(FlowLayout.CENTER));//设置小容器的布局 panel2.add(new JLabel("密 码:")); //添加标签 t1=new JPasswordField("",15); panel2.add(t1); //添加输入框 c.add(panel2); //把小容器放到大容器中 //登录按钮panel JPanel panel3=new JPanel(); //创建小容器 panel3.setLayout(new FlowLayout(FlowLayout.RIGHT));//设置小容器的布局 jb=new JButton("登录"); jb.addActionListener(this); //注册监听者 panel3.add(jb); //添加按钮 c.add(panel3); //把小容器放到大容器中 setVisible(true); //设置可见 map.put("cpt",123456); //列表初始化 map.put("fpy",123456); &#125; //接口函数实现 public void actionPerformed(ActionEvent e) &#123; count--; //测试次数减一 if(count==0) &#123; //若尝试次数超过3次 System.out.println("你没机会了"); System.exit(0); &#125; String name=null; int password=0; try &#123; //获得用户输入 name=t0.getText(); password=Integer.parseInt(t1.getText()); &#125; catch(NumberFormatException ex)&#123; ex.printStackTrace(); &#125; String message=test(name, password);//用户名检验 JOptionPane.showMessageDialog(null,message,"信息提示",JOptionPane.INFORMATION_MESSAGE); //输出提示框 &#125; //检验用户函数 private String test(String name, int password) &#123; //使用Map内部接口Entry进行迭代 for(Map.Entry&lt;String, Integer&gt; entry: map.entrySet()) &#123; String key = entry.getKey(); int value = entry.getValue(); if(key.equals(name))&#123; if("0".equals(String.valueOf(password)) )&#123; return "用户名或密码为空,还有" + count + "次机会"; &#125; else if (!(password == value))&#123; t1.setText(""); return "密码错误,还有" + count + "次机会"; &#125; else &#123; System.out.println("登录成功"); System.exit(0); &#125; &#125; &#125; t1.setText(""); //清空密码 return "用户名是非法的,还有" + count + "次机会"; &#125; //测试函数 public static void main(String[] args) &#123; TestTextField a=new TestTextField("登入界面"); &#125;&#125; 大致效果是酱紫哒！]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常用类实战]]></title>
    <url>%2F2020%2F06%2F05%2FJava%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%AE%9E%E6%88%98.html</url>
    <content type="text"><![CDATA[ArrayList类题：假设52张扑克牌（去掉大小王），实现随机洗牌操作，为参加游戏的人每人生成一手牌，每手牌的牌数是指定的，并将每个人分到的牌按花色排序后输出。 1234567891011121314151617181920212223242526272829303132import java.util.*;public class TestDealCard &#123; public static void main(String[] args) &#123; int numHands=4; int cardsPerHand=12; String[] suit= &#123;"♠","♣","♥","♦"&#125;; String[] rank= &#123;"A","1","2","3","4","5","6","7","8","9","10","J","Q","K"&#125;; List deck = new ArrayList(); for(int i=0;i&lt;suit.length;i++) &#123; for(int j=0;j&lt;rank.length;j++) &#123; deck.add(suit[i]+rank[j]); &#125; &#125; Collections.shuffle(deck); for(int i=0;i&lt;numHands;i++) &#123; List p=dealCard(deck, cardsPerHand); Collections.sort(p); System.out.println(deck); &#125; &#125; public static List dealCard(List deck, int n) &#123; int deckSize=deck.size(); List handView=deck.subList(deckSize-n, deckSize); List hand=new ArrayList(handView); handView.clear(); return hand; &#125;&#125; LinkList类题：用LinkList写一个Stack的数据结构测试。 12345678910111213141516171819202122232425262728293031323334353637import java.util.*;public class TestStack &#123; //创建链表linkList LinkedList linkList=new LinkedList&lt;Object&gt;(); public void push(Object obj) &#123; linkList.addLast(obj); &#125; public void clear() &#123; linkList.clear(); &#125; public boolean isEmpty() &#123; return linkList.isEmpty(); &#125; public int getSize() &#123; return linkList.size(); &#125; public Object pop() &#123; if(!linkList.isEmpty()) return linkList.removeLast(); return "栈内无数"; &#125; public static void main(String[] args) &#123; TestStack myStack=new TestStack(); myStack.push(3); myStack.push(4); myStack.push(5); System.out.println(myStack.pop()); System.out.println(myStack.pop()); &#125;&#125; Vector类题：写一个简单的Vector测试。 123456789101112131415161718192021import java.util.*;public class TestVector &#123; public static void main(String[] args) &#123; Vector v=new Vector(4); v.add("J"); v.add("A"); v.add("J"); v.add("E"); v.add("L"); v.remove("J"); v.remove(0); int size=v.size(); System.out.println("Size:"+size); for(int i=0;i&lt;size;i++) &#123; System.out.println(v.get(i)); &#125; &#125;&#125; 题：演示一个简单的学生信息管理：利用向量记录实现学生管理，能支持学生对象的增加、删除操作，每个学生对象包括学号，性别，姓名。删除学生必须输入学生的学号。可以设计一个操作菜单，包括增加，删除，显示以及退出4项。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.util.*;import java.io.*;public class Student &#123; String name; long stno; String sex; public Student(String name,long stno,String sex) &#123; this.name=name; this.stno=stno; this.sex=sex; &#125; public String toString() &#123; return "姓名:"+name+",学号:"+stno+",性别:"+sex; &#125; public static void main(String[] args) &#123; Vector&lt;Student&gt; group=new Vector&lt;Student&gt;(); outer: while(true) &#123; String ch=input("选择：1--增加，2--删除，3--显示，4--退出"); int choice=Integer.parseInt(ch); switch(choice) &#123; case 1: group.add(inputStudent()); break; case 2: long stno=Long.parseLong(input("请输入学号:")); for(int k=0;k&lt;group.size();k++) &#123; Student x=(Student)group.get(k); if(x.stno==stno) group.removeElement(x); &#125; break; case 3: //迭代输出Vector存储 Iterator p=group.iterator(); while(p.hasNext())&#123; System.out.println("==&gt;"+p.next()); &#125; break; case 4: break outer; &#125; &#125; &#125; public static String input(String hint) &#123; String x=null; try &#123; //字符串输入 BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); System.out.println(hint); x=br.readLine(); &#125; catch(IOException e) &#123;&#125; return x; &#125; public static Student inputStudent() &#123; String name=input("请输入姓名:"); long stno=Long.parseLong(input("请输入学号:")); String sex=input("请输入性别:"); return new Student(name,stno,sex); &#125;&#125; Map类题：写一个测试映射集合的代码。 123456789101112131415161718192021222324252627import java.util.*;public class TestTreeMap &#123; public static void main(String[] args) &#123; Map map=new HashMap(); map.put("c","ccc"); map.put("a","aaa"); map.put("b","bbb"); map.put("d","ddd"); Iterator iter=map.keySet().iterator(); while(iter.hasNext()) &#123; Object key=iter.next(); System.out.println("tab key"+key.toString()+"value="+map.get(key)); &#125; TreeMap tab=new TreeMap(); tab.put("c","ccc"); tab.put("a","aaa"); tab.put("b","bbb"); tab.put("d","ddd"); Iterator iter2=tab.keySet().iterator(); while(iter2.hasNext()) &#123; Object key=iter2.next(); System.out.println("map key"+key.toString()+"value="+tab.get(key)); &#125; &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorBoard实战]]></title>
    <url>%2F2020%2F06%2F05%2FTensorBoard%E5%AE%9E%E6%88%98.html</url>
    <content type="text"><![CDATA[今天我们来介绍一款机器学习中很实用的工具：TensorBoard。它之所以实用，主要是因为它将机器学习这一个类似黑盒的东西可视化出来，让用户对训练过程有一个更好的理解。下面就基于MNIST数据集来实战一下TensorBoard的使用方法。 TensorBoard可视化MNIST分类代码1234567891011121314151617181920212223242526272829303132333435363738import numpy as npfrom keras.layers import Input, Dense, Dropout, Activation, Conv2D, MaxPool2D, Flattenfrom keras.datasets import mnistfrom keras.models import Modelfrom keras.utils import to_categoricalfrom keras.callbacks import TensorBoardif __name__ == '__main__': #数据集处理 data = np.load('mnist.npz') x_train, y_train = data['x_train'], data['y_train'] x_test, y_test = data['x_test'], data['y_test'] x_train = np.expand_dims(x_train, axis=-1) x_test = np.expand_dims(x_test, axis=-1) y_train=to_categorical(y_train, num_classes=10) y_test=to_categorical(y_test, num_classes=10) #参数配置 batch_size =128 epoch = 10 # 模型搭建 inputs = Input([28, 28, 1]) x = Conv2D(32, (5, 5), activation='relu' )(inputs) x = Conv2D(64, (5, 5), activation='relu')(x) x = MaxPool2D(pool_size=(2, 2))(x) x = Flatten()(x) x = Dense(128, activation='relu')(x) x = Dropout(0.5)(x) x = Dense(10, activation='softmax')(x) model = Model(inputs, x) #模型编译 model.compile(loss='categorical_crossentropy', optimizer='adam',metrics=['acc']) #面板配置 Tensorboard = TensorBoard(log_dir='.\model', histogram_freq=1, write_grads=True) #log_dir保存目录 #模型训练 result = model.fit(x_train, y_train, batch_size=batch_size, epochs=epoch, shuffle=True, validation_split=0.2,callbacks=[Tensorboard]) #在回调函数中加入TensorBoard！ TensorBoard启动实际上，训练信息已经保存在TensorBoard配置的目录中了。下面进入当前*.py目录下的PowerShell，敲入 1tensorboard --logdir= XXX（前文中的model） PowerShell会反馈一个本地6006端口开放的提示信息。此时打开浏览器输入 1http://localhost:6006 这样就成功进入TensorBoard界面啦！ TensorBoard配置我们上述实战例子中，我们只能够看到Loss和Acc的训练曲线，而其他信息是没有保存下来的。但世界上TensorBoard的可视化功能非常强大，目前可以支持一下7种可视化类别： SCALARS：展示训练过程中的准确率、损失值、权重/偏置的变化情况 IMAGES：展示训练过程中及记录的图像 AUDIO：展示训练过程中记录的音频 GRAPHS：展示模型的数据流图，以及各个设备上消耗的内存和时间 DISTRIBUTIONS：展示训练过程中记录的数据的分布图 HISTOGRAMS：展示训练过程中记录的数据的柱状图 EMBEDDINGS：展示词向量后的投影分布 具体的参数配置后续再加~ 参考文献： https://blog.csdn.net/fendouaini/article/details/80368770?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase https://blog.csdn.net/u010099080/article/details/77426577 https://blog.csdn.net/hnwolfs/article/details/81122380?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-1]]></content>
      <categories>
        <category>Keras</category>
      </categories>
      <tags>
        <tag>Tensorboard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[screen常用命令]]></title>
    <url>%2F2020%2F06%2F05%2Fscreen%E6%95%99%E7%A8%8B.html</url>
    <content type="text"><![CDATA[​ 想必在Linux云服务器上跑过代码的同学都会有这样子的苦恼：我们通过SSH访问云服务器，将我们需要执行的代码在服务器上运行，但当你断开SSH连接后，你的代码也会随之停止运行。此时你可能开始寻找一种即使SSH离线也能让服务器运行目标代码的方法。这种方法确实存在，那就是下面提到的：screen（窗口）。这个东西实际上可以这样理解：我们通过SSH连接服务器，这时相当于开了一个主窗口。而我们关闭SSH连接后，这个主窗口也就关闭了，所以运行于主窗口的代码也就这样挂掉了。而通过screen操作相当于通过主窗口创建子窗口，主窗口湮灭了但子窗口还是存在的，所以将我们的目标代码放在子窗口运行便能够解决我们上述提到的无法离线运行的问题。 下面就介绍几种screen最常见的操作： screen创建1screen -S ###（窗口名） screen列表查看1screen -ls screen恢复1screen -r ###（窗口名） screen删除1screen -S ###(窗口名) -X quit screen恢复异常12screen -d ###（窗口名）screen -r ###（窗口名） screen返回主窗口1Ctrl + A + D]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>screen</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础练习]]></title>
    <url>%2F2020%2F06%2F01%2FJava%E5%B8%B8%E8%A7%84%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[时间之矢稍纵即逝，接近2周就要Java期末考了。作为一个一学期没怎么认真听Java课的我来说，内心波澜起伏。借着空余的时间，把Java的重点稍微总结了一下，下面就以涵盖全书的4个例子展开。 题1(数组)：使用Scanner输入n个数(小于100)，并将之升序输出。 1234567891011121314151617import java.util.Scanner;import java.util.Arrays;public class haha &#123; public static void main(String[] args)&#123; Scanner reader = new Scanner(System.in); int n = reader.nextInt(); float[] xiang = new float[n]; for(int i=0;i&lt;n;i++) &#123; xiang[i] = reader.nextFloat(); &#125; Arrays.sort(xiang); for(int i=0;i&lt;n;i++) &#123; System.out.println(xiang[i]); &#125; &#125;&#125; 题2(继承)：（1）编写一个圆类Circle，该类拥有：①一个成员变量Radius（私有，浮点型）； // 存放圆的半径；②两个构造方法 Circle( ) // 将半径设为0 Circle(double r ) //创建Circle对象时将半径初始化为r③ 三个成员方法 double getArea( ) //获取圆的面积 double getPerimeter( ) //获取圆的周长 void show( ) //将圆的半径、周长、面积输出到屏幕（2）编写一个圆柱体类Cylinder，它继承于上面的Circle类。还拥有：①一个成员变量 double hight（私有，浮点型）； // 圆柱体的高；②构造方法 Cylinder (double r, double h ) //创建Circle对象时将半径初始化为r③ 成员方法 double getVolume( ) //获取圆柱体的体积 void showVolume( ) //将圆柱体的体积输出到屏幕编写应用程序，创建类的对象，分别设置圆的半径、圆柱体的高，计算并分别显示圆半径、圆面积、圆周长，圆柱体的体积。 Circle.java: 12345678910111213141516171819202122232425public class Circle &#123; private double Radius; public Circle() &#123; Radius=0; &#125; public Circle(double r) &#123; Radius=r; &#125; public double getArea()&#123; return Math.PI*Math.pow(Radius, 2); &#125; public double getPerimeter()&#123; return 2*Math.PI*Radius; &#125; public void show() &#123; System.out.println("圆半径："+Radius); System.out.println("圆面积："+this.getArea()); System.out.println("圆周长:"+this.getPerimeter()); &#125;&#125; Cylinder.java 12345678910111213141516171819202122public class Cylinder extends Circle &#123; private double hight; public Cylinder(double r,double h)&#123; super(r); hight = h; &#125; public double getVolume()&#123; return super.getArea()*hight; &#125; public void showVolume()&#123; System.out.println("圆柱体体积："+this.getVolume()); &#125; public static void main(String[] args) &#123; Cylinder obj = new Cylinder(1,1); obj.show(); obj.showVolume(); &#125;&#125; 题3(抽象类)1.设计Person抽象类，具有年龄、性别、体重、身高等属性，其中年龄、性别为一般方法，体重、身高为抽象方法； 2.在Person抽象类基础上，进一步派生Teacher类，包含工号、系别等信息； 3.设计Teacher测试运行例子，输出相应信息。 Person.java 123456public abstract class Person &#123; void setAge() &#123;&#125; void setSex() &#123;&#125; abstract void setWeight(double weight); abstract void setHeight(double height);&#125; Teacher.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Teacher extends Person&#123; private int age; private String sex; private double weight; private double height; private String document; private String number; Teacher() &#123; age = 0; sex = "x"; document = "xxx"; number = "xxxx"; height = 0; weight = 0; &#125; void setWeight(double w) &#123; weight = w; &#125; void setHeight(double h) &#123; height = h; &#125; void setAge(int a) &#123; age = a; &#125; void setSex(String s) &#123; sex = s; &#125; void setDocument(String s) &#123; document = s; &#125; void setNumber(String s) &#123; number = s; &#125; void show() &#123; System.out.println("teacher"); System.out.println("-------------------------"); System.out.println("age:"+age); System.out.println("sex:"+sex); System.out.println("height:"+height); System.out.println("weight:"+weight); System.out.println("doucument:"+document); System.out.println("number:"+number); &#125; //测试 public static void main(String[] args) &#123; Teacher t = new Teacher(); t.setAge(4); t.setSex("男"); t.setHeight(183.2); t.setWeight(42.5); t.setDocument("自动化"); t.setNumber("1801"); t.show(); &#125;&#125; 题4(接口)： 设计Person接口，具有获取和设置年龄、性别、体重、身高等属性的方法 设计Teacher类实现Person接口，包含工号、系别等信息；实现信息输出功能； 设计Student类实现Person接口，包含学号信息；实现输出功能； 设计Student、Tercher测试运行类，体现接口的应用 Person.java 1234567891011public interface Person &#123; void setAge(int age); int getaAge(); void setSex(String sex); String getSex(); void setHeight(double height); double getHeight(); void setWeight(double W); double getWeight(); void show();&#125; Teacher.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class Teacher implements Person&#123; private int age; private String sex; private String document; private String number; private double height; private double weight; Teacher()&#123; age=0; sex="x"; document="xxx"; number="xxxx"; height=0; weight=0; &#125; public void setAge(int a) &#123; age =a; &#125; public int getAge() &#123; return age; &#125; public void setSex(String s) &#123; sex = s; &#125; public String getSex() &#123; return sex; &#125; public void setHeight(double h) &#123; height=h; &#125; public double getHeight() &#123; return height; &#125; public void setWeight(double w) &#123; weight = w; &#125; public double getWeight() &#123; return weight; &#125; public void setDocument(String d) &#123; document=d; &#125; public void setNumber(String n) &#123; number = n; &#125; public String getNumber() &#123; return number; &#125; public String getDocument() &#123; return document; &#125; public void show() &#123; System.out.println("teacher"); System.out.println("----------------------"); System.out.println("age:"+age); System.out.println("sex:"+sex); System.out.println("height:"+height); System.out.println("weight:"+weight); System.out.println("number:"+number); System.out.println("document:"+document); &#125; public static void main(String[] args) &#123; Teacher t = new Teacher(); t.setAge(123); System.out.println("age:"+t.getAge()); t.setSex("男"); System.out.println("sex:"+t.getSex()); t.setHeight(123.4); System.out.println("heght:"+t.getHeight()); t.show(); &#125;&#125; 还剩下Student类，就…就自行解决吧！毕竟道理都是相通的啦！]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[conda常用命令]]></title>
    <url>%2F2020%2F05%2F29%2Fconda%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[conda可以说是每个学习python的人都应该了解的。当我们安装python包，或者创建环境的时候都会和它打交道。为了帮助大家对conda有一个更好的了解，下面总结了一些关于conda的命令行操作。主要是关于conda换源问题以及conda虚拟环境操作问题。那下面就开始吧！.0.0. window环境下conda查包1conda list conda配置情况查询1conda info conda换源123conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --set show_channel_urls yes conda换回默认源1conda config --remove-key channels conda虚拟环境创建1conda create -n your_env_name python=X.X conda虚拟环境激活1activate your_env_name(虚拟环境名称) conda查询环境信息1conda env list conda关闭虚拟环境1deactivate conda删除虚拟环境1conda remove -n your_env_name(虚拟环境名称) --all conda删除虚拟环境中的某些包1conda remove --name your_env_name package_name Linux环境下如果与windows环境下操作方式相同的，则以下不再赘述。 conda虚拟环境激活1source activate your_env_name(虚拟环境名称) conda关闭虚拟环境1source deactivate conda换源在终端输入： 1vim ~/.condarc 这样就进入了conda源的配置文件了。下面（选择其一就好）将文件改为： 清华源： 123456channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ssl_verify: true 中科大源： 12345channels: - https://mirrors.ustc.edu.cn/anaconda/pkgs/main/ - https://mirrors.ustc.edu.cn/anaconda/pkgs/free/ - https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/ssl_verify: true 上交源： 12345channels: - https://mirrors.sjtug.sjtu.edu.cn/anaconda/pkgs/main/ - https://mirrors.sjtug.sjtu.edu.cn/anaconda/pkgs/free/ - https://mirrors.sjtug.sjtu.edu.cn/anaconda/cloud/conda-forge/ssl_verify: true 参考文献： https://zhuanlan.zhihu.com/p/87123943 https://blog.csdn.net/sean2100/article/details/80998643 https://blog.csdn.net/lyy14011305/article/details/59500819 https://blog.csdn.net/weixin_34613450/article/details/87457631]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>conda命令行</tag>
      </tags>
  </entry>
</search>
